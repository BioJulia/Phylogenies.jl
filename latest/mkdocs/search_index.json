{
    "docs": [
        {
            "location": "/man/phylo/", 
            "text": "Bio.Phylo: Phylogenetic trees and networks\n\n\nThe \nBio.Phylo\n module is for data types and methods for handling phylogenetic trees and networks.\n\n\n\n\nPhylogenies\n\n\n#\n\n\nPhylogenies.Phylogeny\n \n \nType\n.\n\n\nPhylogeny represents a phylogenetic tree.\n\n\nThe type is parametric with two parameters \nC\n and \nB\n.\n\n\nThis is because it is common to want to annotate tips, clades, and branches in a phylogeny with data to create a richer model of evolution of do other things like dictate aesthetic values when plotting.\n\n\nType parameter \nC\n dictates what datatype can be stored in the phylogeny to annotate clades and tips. Type parameter \nB\n dictates what datatype can be stored in the phylogeny to annotate branches. Think \nC\n for clades and \nB\n for branches.\n\n\nsource\n\n\n\n\nConstructors\n\n\nYou can create a very simple unresolved phylogeny (a star phylogeny) by providing the tips as a vector of strings or a vector of symbols.\n\n\n```@example phylo\nusing Bio.Phylo # hide\ntips = [:A, :B, :C]\ntree = Phylogeny(tips)\n\n\n```@example\nusing Bio.Phylo # hide\ntips = [\nA\n, \nB\n, \nC\n]\ntree = Phylogeny(tips)\n\n\n\n\n\n\n\nRoots\n\n\nYou can test whether such a phylogeny is rooted, is re-rootable, and get the root vertex of a phylogeny. You can also test if a vertex of a phylogeny is a root.\n\n\n#\n\n\nPhylogenies.isrooted\n \n \nFunction\n.\n\n\nisrooted(x::Phylogeny)\n\n\n\n\n\nTest whether a Phylogeny is rooted.\n\n\nExamples\n\n\nisrooted\n(\nmy_phylogeny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylogenies.isrerootable\n \n \nFunction\n.\n\n\nisrerootable(x::Phylogeny)\n\n\n\n\n\nTest whether a Phylogeny is re-rootable.\n\n\nExamples\n\n\nisrerootable\n(\nmy_phylogeny\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylogenies.root\n \n \nFunction\n.\n\n\nGet the vertex of the tree which represents the root of the tree.\n\n\nsource\n\n\n```@example phylo\nisrooted(tree)\n\n\n```@example phylo\nisrerootable(tree)\n\n\n\n\n\n@example phylo\nroot(tree)\n\n\n\n\nDivergence time estimation\n\n\nPhylogenies\n has a submodule called \nDating\n which contains methods for divergence time estimation between sequences.\n\n\n\n\nDating methods\n\n\nCurrently \nPhylogenies.Dating\n has two types which are used as function arguments to dictate how to compute coalescence times. They all inherit from the abstract data type \nDatingMethod\n.\n\n\n#\n\n\nPhylogenies.Dating.SimpleEstimate\n \n \nType\n.\n\n\nA very simple expected divergence time estimate. Assumes a strict molecult clock and that the divergence time is equal to\n\n\n$ t = d / (2\\mu) $\n\n\nWhere $d$ is the evolutionary distance computed for two aligned sequences, and $\\mu$ is the substitution rate.\n\n\nsource\n\n\n#\n\n\nPhylogenies.Dating.SpeedDating\n \n \nType\n.\n\n\nSpeedDate\n is the name given to a method of estimating a divergence time between two DNA sequence regions that was first implemented in the R package HybridCheck in order to date regions of introgression in large sequence contigs.\n\n\nThe coalescence time is estimated using the number of mutations that have occurred between two aligned sequences. The calculation uses a strict molecular clock which assumes a constant substitution rate, both through time and across taxa. Modelling the mutation accumulation process as a Bernoulli trial, the probability of observing  $k$  or fewer mutations between two sequences of length $n$ can be given as:\n\n\n$ Pr(X \\le k) = \\sum_{i=0}^{\\lfloor k \\rfloor} \\binom{n}{i} p^i (1 - p)^{n-i} $\n\n\nWhere $p$ is the probability of observing a single mutation between the two aligned sequences. The value of $p$ depends on two key factors: the substitution rate and the coalescence time. If you assume a molecular clock, whereby two DNA sequences are both accumulating mutations at a rate $\\mu$ for $t$ generations, then you may define $p = 2\\mu t$.\n\n\nUsing these assumptions, the SpeedDate method finds the root of the following formula for $Pr(X \\le k) = 0.05$, $0.5$, and $0.95$, and then divides the three answers by twice the assumed substitution rate.\n\n\n$ f(n, k, 2\\mu t, Pr(X \\le k) = \\left( \\sum_{i=0}^{\\lfloor k \\rfloor} \\binom{n}{i} {2\\mu t}^i (1 - 2\\mu t)^{n-i}   \\right) - Pr(X \\le k) $\n\n\nThis results in an upper, middle, and lower estimate of the coalescence time $t$ of the two sequences (expressed as the number of generations).\n\n\nsource", 
            "title": "Phylogenetic Trees"
        }, 
        {
            "location": "/man/phylo/#biophylo-phylogenetic-trees-and-networks", 
            "text": "The  Bio.Phylo  module is for data types and methods for handling phylogenetic trees and networks.", 
            "title": "Bio.Phylo: Phylogenetic trees and networks"
        }, 
        {
            "location": "/man/phylo/#phylogenies", 
            "text": "#  Phylogenies.Phylogeny     Type .  Phylogeny represents a phylogenetic tree.  The type is parametric with two parameters  C  and  B .  This is because it is common to want to annotate tips, clades, and branches in a phylogeny with data to create a richer model of evolution of do other things like dictate aesthetic values when plotting.  Type parameter  C  dictates what datatype can be stored in the phylogeny to annotate clades and tips. Type parameter  B  dictates what datatype can be stored in the phylogeny to annotate branches. Think  C  for clades and  B  for branches.  source", 
            "title": "Phylogenies"
        }, 
        {
            "location": "/man/phylo/#constructors", 
            "text": "You can create a very simple unresolved phylogeny (a star phylogeny) by providing the tips as a vector of strings or a vector of symbols.  ```@example phylo\nusing Bio.Phylo # hide\ntips = [:A, :B, :C]\ntree = Phylogeny(tips)  ```@example\nusing Bio.Phylo # hide\ntips = [ A ,  B ,  C ]\ntree = Phylogeny(tips)", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/phylo/#roots", 
            "text": "You can test whether such a phylogeny is rooted, is re-rootable, and get the root vertex of a phylogeny. You can also test if a vertex of a phylogeny is a root.  #  Phylogenies.isrooted     Function .  isrooted(x::Phylogeny)  Test whether a Phylogeny is rooted.  Examples  isrooted ( my_phylogeny )   source  #  Phylogenies.isrerootable     Function .  isrerootable(x::Phylogeny)  Test whether a Phylogeny is re-rootable.  Examples  isrerootable ( my_phylogeny )   source  #  Phylogenies.root     Function .  Get the vertex of the tree which represents the root of the tree.  source  ```@example phylo\nisrooted(tree)  ```@example phylo\nisrerootable(tree)  @example phylo\nroot(tree)", 
            "title": "Roots"
        }, 
        {
            "location": "/man/phylo/#divergence-time-estimation", 
            "text": "Phylogenies  has a submodule called  Dating  which contains methods for divergence time estimation between sequences.", 
            "title": "Divergence time estimation"
        }, 
        {
            "location": "/man/phylo/#dating-methods", 
            "text": "Currently  Phylogenies.Dating  has two types which are used as function arguments to dictate how to compute coalescence times. They all inherit from the abstract data type  DatingMethod .  #  Phylogenies.Dating.SimpleEstimate     Type .  A very simple expected divergence time estimate. Assumes a strict molecult clock and that the divergence time is equal to  $ t = d / (2\\mu) $  Where $d$ is the evolutionary distance computed for two aligned sequences, and $\\mu$ is the substitution rate.  source  #  Phylogenies.Dating.SpeedDating     Type .  SpeedDate  is the name given to a method of estimating a divergence time between two DNA sequence regions that was first implemented in the R package HybridCheck in order to date regions of introgression in large sequence contigs.  The coalescence time is estimated using the number of mutations that have occurred between two aligned sequences. The calculation uses a strict molecular clock which assumes a constant substitution rate, both through time and across taxa. Modelling the mutation accumulation process as a Bernoulli trial, the probability of observing  $k$  or fewer mutations between two sequences of length $n$ can be given as:  $ Pr(X \\le k) = \\sum_{i=0}^{\\lfloor k \\rfloor} \\binom{n}{i} p^i (1 - p)^{n-i} $  Where $p$ is the probability of observing a single mutation between the two aligned sequences. The value of $p$ depends on two key factors: the substitution rate and the coalescence time. If you assume a molecular clock, whereby two DNA sequences are both accumulating mutations at a rate $\\mu$ for $t$ generations, then you may define $p = 2\\mu t$.  Using these assumptions, the SpeedDate method finds the root of the following formula for $Pr(X \\le k) = 0.05$, $0.5$, and $0.95$, and then divides the three answers by twice the assumed substitution rate.  $ f(n, k, 2\\mu t, Pr(X \\le k) = \\left( \\sum_{i=0}^{\\lfloor k \\rfloor} \\binom{n}{i} {2\\mu t}^i (1 - 2\\mu t)^{n-i}   \\right) - Pr(X \\le k) $  This results in an upper, middle, and lower estimate of the coalescence time $t$ of the two sequences (expressed as the number of generations).  source", 
            "title": "Dating methods"
        }, 
        {
            "location": "/man/contributing/", 
            "text": "Contributing\n\n\nThe BioJulia organization has a set of contribution guidelines which apply to all BioJulia projects.\n\n\nThese guidelines are available \nhere\n and it is recommended all new contributors read these guidelines before opening a pull request.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#contributing", 
            "text": "The BioJulia organization has a set of contribution guidelines which apply to all BioJulia projects.  These guidelines are available  here  and it is recommended all new contributors read these guidelines before opening a pull request.", 
            "title": "Contributing"
        }
    ]
}